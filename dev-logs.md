# 实验目标描述

1. 在小脚丫 FPGA 上实现一个迷你 CPU, 支持 [14条指令](http://recc.robertelder.org/)

2. 在迷你 CPU 上运行[轻量级操作系统](https://github.com/RobertElderSoftware/recc)

3. 改进轻量级操作系统, 包括
    * 增加非对等虚拟内存
    * 增加权限管理
    * 改进进程管理
    * ...

下文中使用 recc 来代指这整个 CPU, 编译, OS 的项目.

------------------------------------------------------------------------------
# 已有工作
## 编译工具链
* [Cpu0 编译器](http://jonathan2251.github.io/lbd/): Cpu0 ISA 上的编译器后端
* [Cpu0 链接器](https://github.com/Jonathan2251/lbt): 针对上面编译器生成的目标文件的链接器
* [LEG 编译器](http://llvm.org/devmtg/2014-10/Slides/Cormack-BuildingAnLLVMBackend.pdf): 一个非常 RISC 的 LEG ISA 的编译器后端
* [汇编器](https://www.embecosm.com/appnotes/ean10/ean10-howto-llvmas-1.0.pdf): 使用 LLVM 设计汇编器

## 操作系统
* [recc 操作系统](https://github.com/RobertElderSoftware/recc/tree/master/kernel)

------------------------------------------------------------------------------

# 日志
__写日志时请按照逆序时间排序__

## 6月6日
* 在内核上跑起来第一个 idle 线程 (事实上是一个内核线程).
  在关中断的情况下, idle 不断 sched. 但是只有一个进程所以一直是 idle sched到 idle.

* 尝试把 idle 和中断结合, 出现了非常奇怪的 bug: 控制流在若干个时钟周期后不稳定.
  还好模拟器环境是确定的, 问题能够稳定复现. 猜想是内核代码某处污染了栈.

## 6月5日
* 内核代码重构
* 尝试跑第一个用户进程 (不是通过 `fork` 实现, 而是直接操作 pcb 实现), 失败

## 6月3日到4日
* 模拟器中增加保护机制
* 内核中增加保护机制, 但是还没有实现 `fork` 等调用, 也没有用户进程.

## 6月1日
* 修改模拟器
  1. 模拟器现在需要模拟真机, 所以放弃 ELF 支持, 只支持内存镜像
  2. 给模拟器加入 TLB 和分页机制. 但是还没测试
  3. 适配 OS, 使得在不打开分页机制情况下原来结果仍可运行

* 发现链接器的问题: lld 3.9 的特性实在太少了, 之前是不支持 `filename(.text)` 只支持 `*(.text)`,
  现在又发现不支持 `PROVIDE(...)`. 不打算解决这个问题: 采用 hack, 假设 kernel image 小于 32 KB.

## 5月25日
* 将编译器中奇怪的命名 `$t9` 变成符合直觉的 `$t2`

* 统一编译器和硬件对于 `jalr` 各个操作数的理解不一致.

* 将硬件的指令集迁移到了新定义的指令集上，完成了测试。

* 成功的在实际硬件上运行了一个小型的操作系统。

## 5月24日
* 修正 Cpu0 中一个导致特定地址的符号的 fixup 无法正常执行的 bug.

* 适配操作系统, 在入口函数中自己初始化 `$sp`, 而非加载器来设置.

* 将 kernel 的编译方法从脚本迁移到 make

* 发现之前的bug是由于on-chip ram的时序问题，这个问题将导致跳转指令无法正常跳转（beq无效，直接ll pc会有一个延迟槽）
> 现在解决了这个问题，ram使用了频率更高的一个时钟（50m，主频是12m），ram现在只会在主频时钟下降沿后ram时钟的第一个上升沿处开始尝试写ram了。

* 进行了中断的测试，很顺利。

## 5月23日
* 分离了编译 C 的 `Cpu0.td` 和编译汇编的 `Cpu0Asm.td`, 不用每次修改 `GPROut` 再编译了.

* 修改报错方式, 从 `assert` 到直接停机, 用 `a0` 寄存器包含错误码

* 尝试将当前工作移植到新的板子上，成功复现了之前的bug.

## 5月21日
* 修复了 `printf` 的问题: recc 自带的 `stdarg.h` 是错误的. 使用 clang 的代替.
  `printf` 能够正确运行.

## 5月20日
* 修正中断, ABI, 栈的 bug, 系统能够构建出正确的 kernel image,
  能够在模拟器上达到和原项目一样的效果, 但是指令仅七千条.

## 5月19日
* 开始从 llvm 工具链构建 kernel image. 编译成功.
  但是运行出现 bug, 包含中断, 以及 printf.

* 发现之前重写的汇编代码有错, 包括 ABI 混乱, 系统调用和中断处理时刻的栈混乱.

## 5月18日
* 发现前期调研出了问题, llvm 实现汇编器很容易. 实现完成汇编器.

* 测试汇编器.

* 经过与向老师的讨论，发现在硬件资源快要占满的时候的确会出现问题，于是从一个学长那拿到了新的板子。

## 5月17日
* cpu似乎出现了严重的bug，现在很多本该正常的功能也不正常了。
> 初步怀疑是因为硬件占满之后被优化之后出现问题。
> 具体的表现为，现在的硬件直接编译的时候会使用8500+逻辑门，然后quartus会花很长时间去优化到7800+（编译时间明显增长），然后烧到板子上是可以烧的，但是接到灯上的东西都不能使用。

## 5月16日
* 重写完操作系统中的汇编代码, 等待汇编器完成

* 重写系统的 `printf` 函数, 现在系统已经没有需要字节访问的函数了.

* 暂时搁置ram中代码执行问题，初步实现了中断，但是因为ram不能正常使用，所以利用sp的指针存入pc的逻辑无法测试。

## 5月15日
* 经过两天调试, 修改了5月12日中发现的 bug. 原因是 TableGen 文件中没有给 `jsub` 指令指定 `isCall`.

* BootLoader应该是没有问题的，但是ram里的代码依然不能正常运行，非常奇怪。

* 顺便在硬件上实现了一个小的调试工具，它可以通过led灯实时监测pc，fr，r1~r9这些寄存器的值、当前正在执行的指令以及一些关键信号的值。

## 5月13日
* 完善[编译器测试](https://bitbucket.org/hoblovski/cpu0-backend-testcases/src)

* 将操作系统中汇编代码改写, 目标是修改后的 ISA.

## 5月12日
* 发现编译器另外一个 bug: 函数中改变的寄存器不能被正确记录,
造成应该被保存的 callee saved register 没有被保存 (到栈上).
经过和 Cpu0 的比对后, 没有看到可能影响这一点的变动;
使用 cgdb 调试, 并研究 llvm 框架代码也没有发现确实的问题.

为了不影响进度, 暂时采用一种粗糙的方法:
函数开始就保存所有 callee saved register
到栈上, 即使其中有一些没有被使用. 修改了 `TargetFrameLoweringImpl.cpp` 的 91 行.

## 5月11日
* 仍未解决全局函数地址的装载. 暂时搁置这个问题, 引入新的指令 `jsub imm26`, 在相对于 PC 的 26 位范围内直接跳转.

## 5月10日
* 完成了一个简单的监控程序，开始着手实现汇编模拟器

* 目前已经实现到了读取汇编代码并做前端分析部分

* 应该可以在这个模拟器的基础上实现一个自己写的汇编器

* 继续 debug 全局函数地址的装载. 没有成功.

## 5月9日
* 开始编译器测试.
因为他的模拟器只接受一个 `extern char*` 的输入不便于我们后续利用 llvm 实现的编译器验证,
所以我基于 C 实现了一个简单的模拟器, 装载可执行 ELF 文件.

* 发现编译器问题: 能装载全局变量地址, 但是全局函数地址无法装载.
这是因为原有 Cpu0 项目支持 24 位范围内直接跳转, 而我们没有实现这个功能.

* 发现汇编器 `as` 是一个问题: 我们现在能把 `.c` 编译成 `.s` 和 `.o`,
  可以把 `.o` 链接成 `a.out`, 但是无法将 `.s` 编译成 `.o`.
  在网络上查找发现没有特别基于 llvm 实现 `as` 的前例, 学长也没做过.
  现在初步有如下解决方案
  1. 除了研究 llvm 后端 (`llc`, `lld`), 还需要研究前端 (`clang`), 完成汇编代码的解析和编译
  2. 事实上 kernel 中只有 400 行汇编, 所以可以尝试手动 reloc ELF hacking.

* 调出了BootLoader的一个小bug，可以在ram里执行一些简单的程序了，但是复杂的程序好像都不行。
> 已经测试那些不能在ram里执行的程序在硬件rom里可以正常执行。
> 似乎不正常的程序都与串口的读写有关。

## 5月8日
* 成功浮现 Cpu0 的链接器. 详情参见 memo.

* 参考 [Cpu0 工具链](http://jonathan2251.github.io/lbt/) 实现了基于 
`lld` 的[链接器](https://bitbucket.org/hoblovski/cpu0-linker/src/master/)
(以后整合到课程仓库中), 能将可重定向目标文件链接成可执行目标文件.

* 学习了链接脚本的写法.

* 开始写一个基于串口的BootLoader，暂时似乎还不能工作，估计是ram的错误。

## 5月6日到7日
* 研究链接器

* 重构编译器后端, 删除不必要的代码

* 检查后端是否可以编译 `recc/kernel`, `recc/libc`, `recc/builtin` 中代码.
	除了一个按字节访问 (LiteCPU 明确说明不支持按字节访问) 的 `vsnprintf`,
	其余均可正常编译生成汇编代码 (`.s`) 和可重定位目标文件 (`.o`).

* 操作系统: 修改os，使它满足gnu规范（clang下不再有编译错误和警告）
还需要修改os的汇编部分使满足gnu规范。

## 5月5日
* 后端基本完成, 能编译简单的 Fibonacci 递归程序到汇编程序.
现在还有一些指令选择模式没有实现, 如 `SELECT_CC`.

* 以后的编译相关工作:
	1. 尝试编译 `recc/kernel` 中文件, 增加指令选择模式
	2. 检查生成代码正确性, 修正编译器中的bug
	3. 消除 `ori` 等指令的存在 (`ori` 可以通过 `addi` 和 `lui` 实现)
	4. 修改指令编码, 能正确生成二进制目标文件
	5. 链接器

* 实现了一个简单的硬件rom(其实因为既可读也可写所以实质上是一个ram，但是未来打算用作BootLoader尽量不去修改，所以叫做rom也无妨）
> 测试了实现的指令，都可以正常运行

## 5月4日
* 后端完成跳转指令, 函数调用基本完成.

## 5月3日
* 在新的方针下进展不错, [后端](https://bitbucket.org/hoblovski/cpu0-backend/src/master/) (完成后集成到课程仓库中) 完成 70% 了.
余下还有跳转指令, 函数调用, 以及具体的链接方法.

* 需要修改指令集和 ISA, 预计是指令条数增加到 17 条, 寄存器缩减到 32 个.

* 完成板子上串口的调试。串口读写正常。

## 5月2日
* 经过十天的尝试, 发现之前**过于乐观**.
本来 llvm 后端的文档就不足,
而其他即使是 RISC 的 ISA 也有远强于 Lite CPU 的描述能力,
因此参考资料也不足.
如果完全按照 Lite CPU 的参考文档和 ABI, 后端构建难度太大.

 * 决定放弃完全按照 `op-cpu.txt` 文档中给出的 ABI.
采用类似 MIPS 的 ABI, 同时尽量少的改动 CPU.

* 采用类似 MIPS 的 ABI, 在一天内已经能成功生成只包含 `add` `sub` 等指令的代码.

## 5月1日
* 从淘宝上买了一个USB转串口的模块，验收完成，初步测试发现可以使用。
> 这里的测试是把那个模块的rxd与txd直接在物理上接起来，然后看是否输给它的东西能否输回给电脑。

## 4月29日
* 拿到了新板子，初步测试发现和之前那块没有什么区别，flash依然不能用。

## 4月27日
* 添加并测试了乘除法指令
> 现在在实际硬件上已经通过测试的指令有add, mul, div, ll, beq，其他的指令还没有在硬件上测试过。但是测试都是一些简单的测试，远远没有上学期的功能测例那样复杂

* 在util里的编译器中添加了一个将硬件指令转为硬编码ram的vhdl的小功能，方便对ram进行硬编码

## 4月25日至26日
* 尝试小脚丫公司给出的flash示例代码，由于这份代码需要使用到51软核，我们无法判断它有没有真正的成功使用片内flash，使用自己的代码来尝试读取也没能成功。联系了小脚丫公司的技术人员，对方表示已经在着手编写仅使用片内flash的示例代码。

* 做了一个新的尝试，不使用flash而是把指令硬编码到ram里（使用logic elements）
	1. 目前成功运行了一段长度为5的代码，暂时还只测试了加法指令和跳转指令（为了让pc不跑到其他的地方去）
	2. 这说明我们的boot loader可以用这种方式硬编码进vhdl里，只要长度不太长的话应该也占不了多少额外的logic elements
	3. 现在硬编码是我强行手敲的，如果以后要采用这种方式可能需要写一个脚本来辅助实现。
	4. 暂时还没有传到github上。


## 4月24日
* 因复习期中开始，暂无进度

## 4月22日至23日
* 对照着官方给出的示例代码再次研究了一下flash相关的问题
	1. 这个flash是嵌入51软核（FP51-1T）的，官方现在给出的答复也是会给出一个单独flash的代码。
	2. 现在这个[flash使用示例](http://stepfpga.com/doc/fpga%E9%A1%B9%E7%9B%AE_%E4%BD%BF%E7%94%A8arduino%E7%8E%A9%E8%BD%ACfpga) 还跑不通，甚至其实连编译都过不了
	3. 详细的信息将添加到memo里 *在写memo的时候突然又编译过了，等待进一步的研究*
	4. 最终跑通了样例也了解了FP51的用法，但是我现在并不知道flash是不是在正常工作，因为原工程最终的结果是反映在一个STEP-baseboard上的东西上的，我没有。需要仔细读一读这个板子工程的代码可能才能知道是否flash在正常工作。

* 这条日志告诉我们，当我们在遇到问题的时候就过来记录一下，说不定记录的过程中问题就没了。

* 对os完成了进一步裁剪，删去了页机制和页缺失异常，kernel image缩小到33196条指令。

* 继续研究 llvm, 感到前景乐观. 预计五一假期结束前完成交叉编译环境的构建 (不包含 litecpu 的指令集针对优化).

## 4月21日
* 成功复现 [Cpu0](http://jonathan2251.github.io/lbd/) 的后端构建.
	复现过程参考 memo.

## 4月18日至20日
* 研究 llvm, 阅读相关文档, 试图重现 [Cpu0](http://jonathan2251.github.io/lbd/) 项目的后端构建.
	1. 负责编译的 dzy 的 4 代 i5 和 4G 小内存编译不动: 缩减目标架构后能够编译, 一次 25 分钟
	2. 编译出现错误 `missing LLVMBuild.txt file`: llvm 不支持 python3, 需要 python2.


## 4月16日至17日
* 研读编译器中的代码生成部分.
	发现 recc 编译器十分没有被优化, 简单的 \a,b: a+b+b 函数都能编译出 100 条指令来.
	ABI 比较混乱, 没有文档, 需要一定时间研究.

* 分析编译生成的代码, 希望增加指令,
	如 `addi rd rs imm`, `subi rd rs imm`, `lul rd imm`, `push rs`, `pop rd`.
	并且希望修改指令, 如 `loa rd offset(rs)` 和 `sto rs offset(rt)`.


## 4月15日
* 裁剪 os 取得重大成就.
	1. 从操作系统中删除文件系统和系统内编译器后,
		kernel image 变为 42235 条 loader 指令.
		相当于在原 kernel image 基础上缩减了 97.63% 的内容.
	2. 因为 kernel image 作为目标文件, 不需要向其他模块暴露符号信息.
		据此从 kernel image 中删去符号信息后,
		kernel image 变为 38015 条 loader 指令.
		又缩减了 10.00% 的内容.

* 更新编译系统的笔记.

* 接下来裁剪 os 的方向
	1. 优化 recc 代码生成. 已有代码生成中包含大量冗余, 如默认返回值.
	2. 优化指令集, 根据 os 代码的特性加入新指令, 如 push, pop, lui 等.

## 4月13日至4月14日
继续研读内核构建过程, 以及研究编译链接结构

## 4月12日
* 实现 CPU
    1. 完成除了乘法，除法之外的所有指令
    2. 通过了已完成部分的仿真测试
    
* 继续尝试使用Flash，还是失败了
    失败的日志记录与经验教训在memo.md中进行了记录，需要进一步的尝试。

* 发现因为片内RAM是不可初始化的，而且确认了没有片内ROM。
    1. 若想要运行代码，需要直接在Flash中先执行一段代码将boot_loader导入内存，然后执行boot_loader，或者直接在Flash中执行boot_loader。
    2. 为了适应在Flash中运行代码的超高延迟，很可能需要调整流水线

## 4月11日
* 开始实现 CPU
    1. 完成脚手架搭建
    2. 成功实现并仿真测试通过第一条指令 `add`.

## 4月10日
* 与向勇老师交流了项目目标，目前确认项目进展顺序如下：
    1. 第一阶段：在现有硬件上实现最简单的CPU，能够运行监控程序（无中断）。
    2. 第二阶段：移植带中断的OS到CPU中。
    3. 第三阶段：在OS中尝试加入虚拟存储。
    4. 第四阶段：在OS中尝试加入权限切换。

* 任意阶段发现FPGA资源不够，且尝试修剪无效时，改为使用更完善的硬件。但需尽力在现有的微型FPGA上实现尽可能多的功能。

## 4月9日
* 交流了项目中主要存在的问题, 并完成大体分工
    1. 在有限的硬件资源上实现一个完整的 CPU (可能还要支持透明TLB)
    2. 将操作系统 (kernel image 6~7 MB) 裁剪, 装入 32KB 的用户flash.
    3. 分工为 zty: kernel, wys: cpu, dzy: compiler

## 4月8日
* 交流会: 我们需要实现的不仅仅是他模拟器的 CPU, 更要考虑将课程中知识点应用.
    1. 我们如何完成对页式内存访问的管理?
        模拟器中是没有 TLB 的, 陈老师希望我们能够把 TLB 直接做到硬件里, 这样软件更简单.
        这样就要考虑软硬件协同, 包括切换页表的时候刷新TLB等.
    2. 最好目标是, 我们写的 CPU (以及编译器) 能够使得 ucoreplus 被编译之后放到 FPGA 中.

* 阅读编译器, 理解了最初的版本 (2d0e734)

## 4月7日
* 发现 kernel image 过大 (光是指令就有 1 MB), 难以写入 FPGA 中 (BRAM 378Kb, UserFlash 32KB).

* 以后工作: 研究裁剪 OS / 优化 kernel image 的大小的方法

## 4月6日
* 更仔细的阅读 recc 源代码, 开始研究 recc 编译器

## 4月4日至4月5日
* 尝试使用片内 flash, 失败.

* 搁置片内 flash 的问题, 等待其他组员一起解决.

## 4月3日
* 片内 RAM 接口摸清楚了.

* 尝试使用片内 flash, 失败.

## 4月1日至4月2日
* FPGA 的 Helloworld 在板子上无法运行, 烧入总是出现 jtag 等的问题.  完全按照 max10 的开发手册也不行.
    详情参见 [memo](https://github.com/AndroidNewsHomework/lightweight-os-dev-docs/blob/master/memo.md#%E6%9D%BF%E5%AD%90%E5%9E%8B%E5%8F%B7%E9%97%AE%E9%A2%98).
    解决是, 发现开发手册中的问题: FPGA 型号不对. 修正后 FPGA 成功运行 Helloworld

## 4月1日前
* 环境配置成功, 重现了 recc, 一切正常


# 实验目标描述

1. 在小脚丫 FPGA 上实现一个迷你 CPU, 支持 [14条指令](http://recc.robertelder.org/)

2. 在迷你 CPU 上运行[轻量级操作系统](https://github.com/RobertElderSoftware/recc)

3. 改进轻量级操作系统, 包括
    * 增加非对等虚拟内存
    * 增加权限管理
    * 改进进程管理
    * ...

下文中使用 recc 来代指这整个 CPU, 编译, OS 的项目.


------------------------------------------------------------------------------

# 已有工作

*TODO*

------------------------------------------------------------------------------

# 日志
__写日志时请按照逆序时间排序__

## 5月21日
* 修复了 `printf` 的问题: recc 自带的 `stdarg.h` 是错误的. 使用 clang 的代替.
  `printf` 能够正确运行.

## 5月20日
* 修正中断, ABI, 栈的 bug, 系统能够构建出正确的 kernel image,
  能够在模拟器上达到和原项目一样的效果, 但是指令仅七千条.

## 5月19日
* 开始从 llvm 工具链构建 kernel image. 编译成功.
  但是运行出现 bug, 包含中断, 以及 printf.

* 发现之前重写的汇编代码有错, 包括 ABI 混乱, 系统调用和中断处理时刻的栈混乱.

## 5月18日
* 发现前期调研出了问题, llvm 实现汇编器很容易. 实现完成汇编器.

* 测试汇编器.

## 5月16日
* 重写完操作系统中的汇编代码, 等待汇编器完成

* 重写系统的 `printf` 函数, 现在系统已经没有需要字节访问的函数了.

## 5月15日
* 经过两天调试, 修改了5月12日中发现的 bug. 原因是 TableGen 文件中没有给 `jsub` 指令指定 `isCall`.

## 5月13日
* 完善[编译器测试](https://bitbucket.org/hoblovski/cpu0-backend-testcases/src)

* 将操作系统中汇编代码改写, 目标是修改后的 ISA.

## 5月12日
* 发现编译器另外一个 bug: 函数中改变的寄存器不能被正确记录,
造成应该被保存的 callee saved register 没有被保存 (到栈上).
经过和 Cpu0 的比对后, 没有看到可能影响这一点的变动;
使用 cgdb 调试, 并研究 llvm 框架代码也没有发现确实的问题.

为了不影响进度, 暂时采用一种粗糙的方法:
函数开始就保存所有 callee saved register
到栈上, 即使其中有一些没有被使用. 修改了 `TargetFrameLoweringImpl.cpp` 的 91 行.

## 5月11日
* 仍未解决全局函数地址的装载. 暂时搁置这个问题, 引入新的指令 `jsub imm26`, 在相对于 PC 的 26 位范围内直接跳转.

## 5月10日
* 完成了一个简单的监控程序，开始着手实现汇编模拟器

* 目前已经实现到了读取汇编代码并做前端分析部分

* 应该可以在这个模拟器的基础上实现一个自己写的汇编器

* 继续 debug 全局函数地址的装载. 没有成功.

## 5月9日
* 开始编译器测试.
因为他的模拟器只接受一个 `extern char*` 的输入不便于我们后续利用 llvm 实现的编译器验证,
所以我基于 C 实现了一个简单的模拟器, 装载可执行 ELF 文件.

* 发现编译器问题: 能装载全局变量地址, 但是全局函数地址无法装载.
这是因为原有 Cpu0 项目支持 24 位范围内直接跳转, 而我们没有实现这个功能.

* 发现汇编器 `as` 是一个问题: 我们现在能把 `.c` 编译成 `.s` 和 `.o`,
  可以把 `.o` 链接成 `a.out`, 但是无法将 `.s` 编译成 `.o`.
  在网络上查找发现没有特别基于 llvm 实现 `as` 的前例, 学长也没做过.
  现在初步有如下解决方案
  1. 除了研究 llvm 后端 (`llc`, `lld`), 还需要研究前端 (`clang`), 完成汇编代码的解析和编译
  2. 事实上 kernel 中只有 400 行汇编, 所以可以尝试手动 reloc ELF hacking.

## 5月8日
* 成功浮现 Cpu0 的链接器. 详情参见 memo.

* 参考 [Cpu0 工具链](http://jonathan2251.github.io/lbt/) 实现了基于 
`lld` 的[链接器](https://bitbucket.org/hoblovski/cpu0-linker/src/master/)
(以后整合到课程仓库中), 能将可重定向目标文件链接成可执行目标文件.

* 学习了链接脚本的写法.

## 5月6日到7日
* 研究链接器

* 重构编译器后端, 删除不必要的代码

* 检查后端是否可以编译 `recc/kernel`, `recc/libc`, `recc/builtin` 中代码.
	除了一个按字节访问 (LiteCPU 明确说明不支持按字节访问) 的 `vsnprintf`,
	其余均可正常编译生成汇编代码 (`.s`) 和可重定位目标文件 (`.o`).

* 操作系统: 修改os，使它满足gnu规范（clang下不再有编译错误和警告）
还需要修改os的汇编部分使满足gnu规范。

## 5月5日
* 后端基本完成, 能编译简单的 Fibonacci 递归程序到汇编程序.
现在还有一些指令选择模式没有实现, 如 `SELECT_CC`.

* 以后的编译相关工作:
	1. 尝试编译 `recc/kernel` 中文件, 增加指令选择模式
	2. 检查生成代码正确性, 修正编译器中的bug
	3. 消除 `ori` 等指令的存在 (`ori` 可以通过 `addi` 和 `lui` 实现)
	4. 修改指令编码, 能正确生成二进制目标文件
	5. 链接器

## 5月4日
* 后端完成跳转指令, 函数调用基本完成.

## 5月3日
* 在新的方针下进展不错, [后端](https://bitbucket.org/hoblovski/cpu0-backend/src/master/) (完成后集成到课程仓库中) 完成 70% 了.
余下还有跳转指令, 函数调用, 以及具体的链接方法.

* 需要修改指令集和 ISA, 预计是指令条数增加到 17 条, 寄存器缩减到 32 个.

## 5月2日
* 经过十天的尝试, 发现之前**过于乐观**.
本来 llvm 后端的文档就不足,
而其他即使是 RISC 的 ISA 也有远强于 Lite CPU 的描述能力,
因此参考资料也不足.
如果完全按照 Lite CPU 的参考文档和 ABI, 后端构建难度太大.

 * 决定放弃完全按照 `op-cpu.txt` 文档中给出的 ABI.
采用类似 MIPS 的 ABI, 同时尽量少的改动 CPU.

* 采用类似 MIPS 的 ABI, 在一天内已经能成功生成只包含 `add` `sub` 等指令的代码.

## 4月27日
* 添加并测试了乘除法指令
> 现在在实际硬件上已经通过测试的指令有add, mul, div, ll, beq，其他的指令还没有在硬件上测试过。但是测试都是一些简单的测试，远远没有上学期的功能测例那样复杂

* 在util里的编译器中添加了一个将硬件指令转为硬编码ram的vhdl的小功能，方便对ram进行硬编码

## 4月25日至26日
* 尝试小脚丫公司给出的flash示例代码，由于这份代码需要使用到51软核，我们无法判断它有没有真正的成功使用片内flash，使用自己的代码来尝试读取也没能成功。联系了小脚丫公司的技术人员，对方表示已经在着手编写仅使用片内flash的示例代码。

* 做了一个新的尝试，不使用flash而是把指令硬编码到ram里（使用logic elements）
	1. 目前成功运行了一段长度为5的代码，暂时还只测试了加法指令和跳转指令（为了让pc不跑到其他的地方去）
	2. 这说明我们的boot loader可以用这种方式硬编码进vhdl里，只要长度不太长的话应该也占不了多少额外的logic elements
	3. 现在硬编码是我强行手敲的，如果以后要采用这种方式可能需要写一个脚本来辅助实现。
	4. 暂时还没有传到github上。


## 4月24日
* 因复习期中开始，暂无进度

## 4月22日至23日
* 对照着官方给出的示例代码再次研究了一下flash相关的问题
	1. 这个flash是嵌入51软核（FP51-1T）的，官方现在给出的答复也是会给出一个单独flash的代码。
	2. 现在这个[flash使用示例](http://stepfpga.com/doc/fpga%E9%A1%B9%E7%9B%AE_%E4%BD%BF%E7%94%A8arduino%E7%8E%A9%E8%BD%ACfpga) 还跑不通，甚至其实连编译都过不了
	3. 详细的信息将添加到memo里 *在写memo的时候突然又编译过了，等待进一步的研究*
	4. 最终跑通了样例也了解了FP51的用法，但是我现在并不知道flash是不是在正常工作，因为原工程最终的结果是反映在一个STEP-baseboard上的东西上的，我没有。需要仔细读一读这个板子工程的代码可能才能知道是否flash在正常工作。

* 这条日志告诉我们，当我们在遇到问题的时候就过来记录一下，说不定记录的过程中问题就没了。

* 对os完成了进一步裁剪，删去了页机制和页缺失异常，kernel image缩小到33196条指令。

* 继续研究 llvm, 感到前景乐观. 预计五一假期结束前完成交叉编译环境的构建 (不包含 litecpu 的指令集针对优化).

## 4月21日
* 成功复现 [Cpu0](http://jonathan2251.github.io/lbd/) 的后端构建.
	复现过程参考 memo.

## 4月18日至20日
* 研究 llvm, 阅读相关文档, 试图重现 [Cpu0](http://jonathan2251.github.io/lbd/) 项目的后端构建.
	1. 负责编译的 dzy 的 4 代 i5 和 4G 小内存编译不动: 缩减目标架构后能够编译, 一次 25 分钟
	2. 编译出现错误 `missing LLVMBuild.txt file`: llvm 不支持 python3, 需要 python2.


## 4月16日至17日
* 研读编译器中的代码生成部分.
	发现 recc 编译器十分没有被优化, 简单的 \a,b: a+b+b 函数都能编译出 100 条指令来.
	ABI 比较混乱, 没有文档, 需要一定时间研究.

* 分析编译生成的代码, 希望增加指令,
	如 `addi rd rs imm`, `subi rd rs imm`, `lul rd imm`, `push rs`, `pop rd`.
	并且希望修改指令, 如 `loa rd offset(rs)` 和 `sto rs offset(rt)`.


## 4月15日
* 裁剪 os 取得重大成就.
	1. 从操作系统中删除文件系统和系统内编译器后,
		kernel image 变为 42235 条 loader 指令.
		相当于在原 kernel image 基础上缩减了 97.63% 的内容.
	2. 因为 kernel image 作为目标文件, 不需要向其他模块暴露符号信息.
		据此从 kernel image 中删去符号信息后,
		kernel image 变为 38015 条 loader 指令.
		又缩减了 10.00% 的内容.

* 更新编译系统的笔记.

* 接下来裁剪 os 的方向
	1. 优化 recc 代码生成. 已有代码生成中包含大量冗余, 如默认返回值.
	2. 优化指令集, 根据 os 代码的特性加入新指令, 如 push, pop, lui 等.

## 4月13日至4月14日
继续研读内核构建过程, 以及研究编译链接结构

## 4月12日
* 实现 CPU
    1. 完成除了乘法，除法之外的所有指令
    2. 通过了已完成部分的仿真测试
    
* 继续尝试使用Flash，还是失败了
    失败的日志记录与经验教训在memo.md中进行了记录，需要进一步的尝试。

* 发现因为片内RAM是不可初始化的，而且确认了没有片内ROM。
    1. 若想要运行代码，需要直接在Flash中先执行一段代码将boot_loader导入内存，然后执行boot_loader，或者直接在Flash中执行boot_loader。
    2. 为了适应在Flash中运行代码的超高延迟，很可能需要调整流水线

## 4月11日
* 开始实现 CPU
    1. 完成脚手架搭建
    2. 成功实现并仿真测试通过第一条指令 `add`.

## 4月10日
* 与向勇老师交流了项目目标，目前确认项目进展顺序如下：
    1. 第一阶段：在现有硬件上实现最简单的CPU，能够运行监控程序（无中断）。
    2. 第二阶段：移植带中断的OS到CPU中。
    3. 第三阶段：在OS中尝试加入虚拟存储。
    4. 第四阶段：在OS中尝试加入权限切换。

* 任意阶段发现FPGA资源不够，且尝试修剪无效时，改为使用更完善的硬件。但需尽力在现有的微型FPGA上实现尽可能多的功能。

## 4月9日
* 交流了项目中主要存在的问题, 并完成大体分工
    1. 在有限的硬件资源上实现一个完整的 CPU (可能还要支持透明TLB)
    2. 将操作系统 (kernel image 6~7 MB) 裁剪, 装入 32KB 的用户flash.
    3. 分工为 zty: kernel, wys: cpu, dzy: compiler

## 4月8日
* 交流会: 我们需要实现的不仅仅是他模拟器的 CPU, 更要考虑将课程中知识点应用.
    1. 我们如何完成对页式内存访问的管理?
        模拟器中是没有 TLB 的, 陈老师希望我们能够把 TLB 直接做到硬件里, 这样软件更简单.
        这样就要考虑软硬件协同, 包括切换页表的时候刷新TLB等.
    2. 最好目标是, 我们写的 CPU (以及编译器) 能够使得 ucoreplus 被编译之后放到 FPGA 中.

* 阅读编译器, 理解了最初的版本 (2d0e734)

## 4月7日
* 发现 kernel image 过大 (光是指令就有 1 MB), 难以写入 FPGA 中 (BRAM 378Kb, UserFlash 32KB).

* 以后工作: 研究裁剪 OS / 优化 kernel image 的大小的方法

## 4月6日
* 更仔细的阅读 recc 源代码, 开始研究 recc 编译器

## 4月4日至4月5日
* 尝试使用片内 flash, 失败.

* 搁置片内 flash 的问题, 等待其他组员一起解决.

## 4月3日
* 片内 RAM 接口摸清楚了.

* 尝试使用片内 flash, 失败.

## 4月1日至4月2日
* FPGA 的 Helloworld 在板子上无法运行, 烧入总是出现 jtag 等的问题.  完全按照 max10 的开发手册也不行.
    详情参见 [memo](https://github.com/AndroidNewsHomework/lightweight-os-dev-docs/blob/master/memo.md#%E6%9D%BF%E5%AD%90%E5%9E%8B%E5%8F%B7%E9%97%AE%E9%A2%98).
    解决是, 发现开发手册中的问题: FPGA 型号不对. 修正后 FPGA 成功运行 Helloworld

## 4月1日前
* 环境配置成功, 重现了 recc, 一切正常


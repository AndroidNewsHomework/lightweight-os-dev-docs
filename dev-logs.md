# 实验目标描述

1. 在小脚丫 FPGA 上实现一个迷你 CPU, 支持 [14条指令](http://recc.robertelder.org/)

2. 在迷你 CPU 上运行[轻量级操作系统](https://github.com/RobertElderSoftware/recc)

3. 改进轻量级操作系统, 包括
    * 增加非对等虚拟内存
    * 增加权限管理
    * 改进进程管理
    * ...

下文中使用 recc 来代指这整个 CPU, 编译, OS 的项目.


------------------------------------------------------------------------------

# 已有工作

*TODO*

------------------------------------------------------------------------------

# 日志
__写日志时请按照逆序时间排序__

## 5月2日
* 经过十天的尝试, 决定放弃完全按照 `op-cpu.txt` 文档中给出的 ABI.
采用类似 MIPS 的 ABI, 同时尽量少的改动 CPU.
* 采用类似 MIPS 的 ABI, 在一天内已经能成功生成只包含 `add` `sub` 等指令的代码.

## 4月27日
* 添加并测试了乘除法指令
> 现在在实际硬件上已经通过测试的指令有add, mul, div, ll, beq，其他的指令还没有在硬件上测试过。但是测试都是一些简单的测试，远远没有上学期的功能测例那样复杂
* 在util里的编译器中添加了一个将硬件指令转为硬编码ram的vhdl的小功能，方便对ram进行硬编码

## 4月25日至26日
* 尝试小脚丫公司给出的flash示例代码，由于这份代码需要使用到51软核，我们无法判断它有没有真正的成功使用片内flash，使用自己的代码来尝试读取也没能成功。联系了小脚丫公司的技术人员，对方表示已经在着手编写仅使用片内flash的示例代码。
* 做了一个新的尝试，不使用flash而是把指令硬编码到ram里（使用logic elements）
	1. 目前成功运行了一段长度为5的代码，暂时还只测试了加法指令和跳转指令（为了让pc不跑到其他的地方去）
	2. 这说明我们的boot loader可以用这种方式硬编码进vhdl里，只要长度不太长的话应该也占不了多少额外的logic elements
	3. 现在硬编码是我强行手敲的，如果以后要采用这种方式可能需要写一个脚本来辅助实现。
	4. 暂时还没有传到github上。


## 4月24日
* 因复习期中开始，暂无进度

## 4月22日至23日
* 对照着官方给出的示例代码再次研究了一下flash相关的问题
	1. 这个flash是嵌入51软核（FP51-1T）的，官方现在给出的答复也是会给出一个单独flash的代码。
	2. 现在这个[flash使用示例](http://stepfpga.com/doc/fpga%E9%A1%B9%E7%9B%AE_%E4%BD%BF%E7%94%A8arduino%E7%8E%A9%E8%BD%ACfpga) 还跑不通，甚至其实连编译都过不了
	3. 详细的信息将添加到memo里 *在写memo的时候突然又编译过了，等待进一步的研究*
	4. 最终跑通了样例也了解了FP51的用法，但是我现在并不知道flash是不是在正常工作，因为原工程最终的结果是反映在一个STEP-baseboard上的东西上的，我没有。需要仔细读一读这个板子工程的代码可能才能知道是否flash在正常工作。

* 这条日志告诉我们，当我们在遇到问题的时候就过来记录一下，说不定记录的过程中问题就没了。

* 对os完成了进一步裁剪，删去了页机制和页缺失异常，kernel image缩小到33196条指令。

* 继续研究 llvm, 感到前景乐观. 预计五一假期结束前完成交叉编译环境的构建 (不包含 litecpu 的指令集针对优化).

## 4月21日
* 成功复现 [Cpu0](http://jonathan2251.github.io/lbd/) 的后端构建.
	复现过程参考 memo.

## 4月18日至20日
* 研究 llvm, 阅读相关文档, 试图重现 [Cpu0](http://jonathan2251.github.io/lbd/) 项目的后端构建.
	1. 负责编译的 dzy 的 4 代 i5 和 4G 小内存编译不动: 缩减目标架构后能够编译, 一次 25 分钟
	2. 编译出现错误 `missing LLVMBuild.txt file`: llvm 不支持 python3, 需要 python2.


## 4月16日至17日
* 研读编译器中的代码生成部分.
	发现 recc 编译器十分没有被优化, 简单的 \a,b: a+b+b 函数都能编译出 100 条指令来.
	ABI 比较混乱, 没有文档, 需要一定时间研究.

* 分析编译生成的代码, 希望增加指令,
	如 `addi rd rs imm`, `subi rd rs imm`, `lul rd imm`, `push rs`, `pop rd`.
	并且希望修改指令, 如 `loa rd offset(rs)` 和 `sto rs offset(rt)`.


## 4月15日
* 裁剪 os 取得重大成就.
	1. 从操作系统中删除文件系统和系统内编译器后,
		kernel image 变为 42235 条 loader 指令.
		相当于在原 kernel image 基础上缩减了 97.63% 的内容.
	2. 因为 kernel image 作为目标文件, 不需要向其他模块暴露符号信息.
		据此从 kernel image 中删去符号信息后,
		kernel image 变为 38015 条 loader 指令.
		又缩减了 10.00% 的内容.

* 更新编译系统的笔记.

* 接下来裁剪 os 的方向
	1. 优化 recc 代码生成. 已有代码生成中包含大量冗余, 如默认返回值.
	2. 优化指令集, 根据 os 代码的特性加入新指令, 如 push, pop, lui 等.

## 4月13日至4月14日
继续研读内核构建过程, 以及研究编译链接结构

## 4月12日
* 实现 CPU
    1. 完成除了乘法，除法之外的所有指令
    2. 通过了已完成部分的仿真测试
    
* 继续尝试使用Flash，还是失败了
    失败的日志记录与经验教训在memo.md中进行了记录，需要进一步的尝试。

* 发现因为片内RAM是不可初始化的，而且确认了没有片内ROM。
    1. 若想要运行代码，需要直接在Flash中先执行一段代码将boot_loader导入内存，然后执行boot_loader，或者直接在Flash中执行boot_loader。
    2. 为了适应在Flash中运行代码的超高延迟，很可能需要调整流水线

## 4月11日
* 开始实现 CPU
    1. 完成脚手架搭建
    2. 成功实现并仿真测试通过第一条指令 `add`.

## 4月10日
* 与向勇老师交流了项目目标，目前确认项目进展顺序如下：
    1. 第一阶段：在现有硬件上实现最简单的CPU，能够运行监控程序（无中断）。
    2. 第二阶段：移植带中断的OS到CPU中。
    3. 第三阶段：在OS中尝试加入虚拟存储。
    4. 第四阶段：在OS中尝试加入权限切换。

* 任意阶段发现FPGA资源不够，且尝试修剪无效时，改为使用更完善的硬件。但需尽力在现有的微型FPGA上实现尽可能多的功能。

## 4月9日
* 交流了项目中主要存在的问题, 并完成大体分工
    1. 在有限的硬件资源上实现一个完整的 CPU (可能还要支持透明TLB)
    2. 将操作系统 (kernel image 6~7 MB) 裁剪, 装入 32KB 的用户flash.
    3. 分工为 zty: kernel, wys: cpu, dzy: compiler

## 4月8日
* 交流会: 我们需要实现的不仅仅是他模拟器的 CPU, 更要考虑将课程中知识点应用.
    1. 我们如何完成对页式内存访问的管理?
        模拟器中是没有 TLB 的, 陈老师希望我们能够把 TLB 直接做到硬件里, 这样软件更简单.
        这样就要考虑软硬件协同, 包括切换页表的时候刷新TLB等.
    2. 最好目标是, 我们写的 CPU (以及编译器) 能够使得 ucoreplus 被编译之后放到 FPGA 中.

* 阅读编译器, 理解了最初的版本 (2d0e734)

## 4月7日
* 发现 kernel image 过大 (光是指令就有 1 MB), 难以写入 FPGA 中 (BRAM 378Kb, UserFlash 32KB).

*TODO*: 研究裁剪 OS / 优化 kernel image 的大小的方法

## 4月6日
* 更仔细的阅读 recc 源代码, 开始研究 recc 编译器

## 4月4日至4月5日
* 尝试使用片内 flash, 失败.

* 搁置片内 flash 的问题, 等待其他组员一起解决.

## 4月3日
* 片内 RAM 接口摸清楚了.

* 尝试使用片内 flash, 失败.

## 4月1日至4月2日
* FPGA 的 Helloworld 在板子上无法运行, 烧入总是出现 jtag 等的问题.  完全按照 max10 的开发手册也不行.
    详情参见 [memo](https://github.com/AndroidNewsHomework/lightweight-os-dev-docs/blob/master/memo.md#%E6%9D%BF%E5%AD%90%E5%9E%8B%E5%8F%B7%E9%97%AE%E9%A2%98).
    解决是, 发现开发手册中的问题: FPGA 型号不对. 修正后 FPGA 成功运行 Helloworld

## 4月1日前
* 环境配置成功, 重现了 recc, 一切正常

